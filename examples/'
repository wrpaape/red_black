#include "red_black_tree.h" /* RedblackTree|Iterator */
#include "str_key.h"	    /* string comparator */
#include "examples_io.h"    /* READ/WRITE/EXIT macros, stdlib (malloc/free) */
#include <string.h>	    /* memcpy */


/* string literals
 * ────────────────────────────────────────────────────────────────────────── */
#define HEADER								    \
"         NAME          |         PHONE         |         EMAIL         \n" \
"=======================|=======================|=======================\n"
#define HEADER_LENGTH (sizeof(HEADER) - 1)

#define ENTER_NAME  "enter name\n> "
#define ENTER_PHONE "enter phone number\n> "
#define ENTER_EMAIL "enter email address\n> "

#define MAX_LENGTH	23
#define MAX_LENGTH_STR	"23"

/* helpful macros
 * ────────────────────────────────────────────────────────────────────────── */
#define MALLOC(BUFFER,							\
	       SIZE)							\
if (((BUFFER) = malloc(SIZE)) == NULL)					\
	EXIT_ON_FAILURE("OUT OF MEMORY")

#define FIELD_TOO_LONG()						\
WRITE_LITERAL("FIELD TOO LONG! max length is " MAX_LENGTH_STR " characters.\n")


/* typedefs, struct declarations
 * ────────────────────────────────────────────────────────────────────────── */
struct Contact {
	char name[MAX_LENGTH + 1];  /* keep key as 1st field, degrades to ptr */
	char phone[MAX_LENGTH + 1];
	char email[MAX_LENGTH + 1];
};


/* global variables
 * ────────────────────────────────────────────────────────────────────────── */
static RedBlackTree contacts;
static unsigned int count_contacts;
static struct Contact *restrict scratch_contact;

static inline char *
put_field(char *restrict buffer,
	  const char *restrict field)
{
	char *const restrict buffer_upto = buffer + MAX_LENGTH;

	while (*field != '\0') /* copy field */
		*buffer++ = *field++;

	while (buffer < buffer_upto) /* add padding */
		*buffer++ = ' ';

	return buffer;
}

static inline char *
put_contact(char *restrict buffer,
	    const struct Contact *const restrict contact)
{
	buffer = put_field(buffer,
			   &contact->name[0]);

	*buffer++ = '|'; /* put separator */

	buffer = put_field(buffer,
			   &contact->phone[0]);

	*buffer++ = '|'; /* put separator */

	buffer = put_field(buffer,
			   &contact->email[0]);

	*buffer++ = '\n'; /* put newline */

	return buffer;
}

static inline char *
put_contacts(char *restrict buffer)
{
	RedBlackTreeIterator iterator;
	struct Contact *restrict contact;

	(void) memcpy(buffer,
		      HEADER,
		      HEADER_LENGTH);

	buffer += HEADER_LENGTH;

	red_black_tree_iterator_init_asc(&iterator,
					 &contacts);

	while (red_black_tree_iterator_next(&iterator,
					    &contact))
		buffer = put_contact(buffer,
				     contact);

	return buffer;
}

static inline void
print_contacts(void)
{
	size_t size;
	char *restrict buffer;
	char *restrict end_ptr;

	size = HEADER_LENGTH + (count_contacts * sizeof(struct Contact));

	MALLOC(buffer,
	       size_buffer);

	if (buffer == NULL)
		EXIT_ON_FAILURE("OUT OF MEMORY");

	end_ptr = put_contacts(buffer);

	size = end_ptr - buffer;

	WRITE_STDOUT(buffer,
		     size);

	free(buffer);
}

static inline void
insert_contact(void)
{
	ssize_t size_read;

	WRITE_LITERAL(ENTER_NAME);

	if (scratch_contact == NULL)

	size_read = READ_INPUT()

}


int
main(void)
{

}
